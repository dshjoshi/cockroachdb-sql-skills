# SCHEMA DESIGN

## Data Type Normalization

### Type Mapping Rules
```sql
-- Integer types
INTEGER, INT → INT8          -- 64-bit by default
BIGINT → INT8                 -- Already 64-bit
SMALLINT → INT2               -- 16-bit
INT4 → INT4                   -- 32-bit when explicitly needed

-- String types
TEXT → STRING                 -- CockroachDB prefers STRING
CHAR(n) → CHAR(n)            -- Fixed length preserved
VARCHAR → VARCHAR             -- Variable length
NAME → NAME                   -- Special 64-byte type

-- Boolean
BOOL → BOOLEAN               -- Normalized form

-- Decimal
NUMERIC → DECIMAL            -- Both work, DECIMAL preferred
NUMERIC(p,s) → DECIMAL(p,s)  -- With precision/scale

-- JSON
JSON → JSONB                 -- Always stored as binary JSON

-- Timestamp
TIMESTAMP → TIMESTAMPTZ      -- Timezone-aware by default
```

### Complex Types
```sql
-- Arrays (use base type normalization)
INT[] → INT8[]               -- Note: INT8, not INT
VARCHAR(50)[] → VARCHAR(50)[]

-- Vectors (AI/ML embeddings)
VECTOR(1536)                 -- Dimension must be specified (1-65535)

-- Spatial types
GEOMETRY(POINT, 4326)        -- With optional SRID
GEOGRAPHY                    -- For Earth-based coordinates

-- Special types
UUID                         -- Universally unique identifier
INET                         -- IPv4/IPv6 addresses
INTERVAL                     -- Time intervals
```

## Table Creation Patterns

### Basic Structure
```sql
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email STRING NOT NULL UNIQUE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now() ON UPDATE now(),
    metadata JSONB,
    FAMILY primary_data (id, email, created_at),
    FAMILY json_data (metadata),
    FAMILY update_tracking (updated_at)
);
```

### Multi-Region Tables
```sql
-- Global table (replicated everywhere)
CREATE TABLE config (
    key STRING PRIMARY KEY,
    value JSONB
) LOCALITY GLOBAL;

-- Regional table (pinned to region)
CREATE TABLE regional_data (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid()
) LOCALITY REGIONAL BY TABLE IN us_west;

-- Regional by row (data follows the user)
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    region STRING NOT NULL,
    CONSTRAINT region_check CHECK (region IN ('us_west', 'us_east', 'eu'))
) LOCALITY REGIONAL BY ROW AS region;
```

## Primary Key Strategies

### UUID (Recommended for Distribution)
```sql
id UUID PRIMARY KEY DEFAULT gen_random_uuid()
```

### Composite Keys
```sql
PRIMARY KEY (tenant_id, created_at DESC, id)
-- Provides natural ordering and tenant isolation
```

### Identity Columns
```sql
-- Preferred over SERIAL
id INT8 GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY

-- With custom sequence
id INT8 GENERATED ALWAYS AS IDENTITY (START WITH 1000) PRIMARY KEY
```

### Avoid These Patterns
```sql
-- AUTO_INCREMENT not supported
-- SERIAL creates sequences (avoid in distributed systems)
-- Sequential IDs cause hotspots
```

## Index Patterns

### Standard Indexes
```sql
-- B-tree (default)
CREATE INDEX idx_email ON users (email);

-- Unique
CREATE UNIQUE INDEX idx_unique_email ON users (email) WHERE deleted_at IS NULL;

-- Partial (filtered)
CREATE INDEX idx_active ON users (status) WHERE status = 'active';

-- Covering (with STORING)
CREATE INDEX idx_lookup ON orders (user_id) STORING (total, status);

-- Descending
CREATE INDEX idx_recent ON events (created_at DESC);
```

### Special Index Types
```sql
-- Hash-sharded (prevent hotspots)
CREATE INDEX idx_sharded ON events (created_at)
USING HASH WITH (bucket_count = 8);

-- Inverted (for JSON/arrays)
CREATE INVERTED INDEX idx_tags ON posts (tags);
CREATE INVERTED INDEX idx_json ON documents ((metadata->'tags'));

-- Vector (for similarity search)
CREATE INDEX idx_embedding ON items (embedding vector_ip_ops)
WITH (type='hnsw', m=16, ef_construction=64);

-- Spatial (GiST)
CREATE INDEX idx_location ON stores USING GIST (location);

-- Full-text search
CREATE INDEX idx_search ON articles
USING GIN ((to_tsvector('english', title || ' ' || body)));
```

### Index Management
```sql
-- Invisible index (for testing)
CREATE INDEX idx_test ON users (email) NOT VISIBLE;
ALTER INDEX idx_test VISIBLE;

-- Force index usage
SELECT * FROM users@idx_email WHERE email = 'user@example.com';
```

## Constraints

### Foreign Keys
```sql
-- Basic with cascade
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;

-- All actions
ON DELETE CASCADE | RESTRICT | SET NULL | SET DEFAULT | NO ACTION
ON UPDATE CASCADE | RESTRICT | SET NULL | SET DEFAULT | NO ACTION

-- Multi-column with MATCH FULL
FOREIGN KEY (tenant_id, user_id)
REFERENCES users(tenant_id, id)
MATCH FULL ON DELETE CASCADE;
```

### Check Constraints
```sql
-- Column level
age INT CHECK (age >= 0 AND age <= 150)

-- Table level
CONSTRAINT valid_dates CHECK (start_date < end_date)

-- Complex validation
CONSTRAINT valid_json CHECK (
    jsonb_typeof(metadata) = 'object' AND
    metadata ? 'required_field'
)
```

### Computed Columns
```sql
-- STORED (persisted)
full_name STRING AS (first_name || ' ' || last_name) STORED

-- VIRTUAL (calculated on read)
age INT AS (EXTRACT(YEAR FROM age(current_date, birth_date))) VIRTUAL
```

### Unique Constraints
```sql
-- Simple
UNIQUE (email)

-- Composite
UNIQUE (tenant_id, email)

-- Partial (conditional)
UNIQUE INDEX idx_unique_active ON users (email) WHERE deleted_at IS NULL

-- Named constraint
CONSTRAINT unique_email UNIQUE (email)
```

## Partitioning

### Range Partitioning (Time-based)
```sql
CREATE TABLE events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at TIMESTAMPTZ NOT NULL,
    data JSONB
) PARTITION BY RANGE (created_at);

-- Create partitions
CREATE TABLE events_2024_01 PARTITION OF events
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE events_default PARTITION OF events
    FOR VALUES FROM ('2024-02-01') TO (MAXVALUE);
```

### List Partitioning (Value-based)
```sql
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    region STRING NOT NULL
) PARTITION BY LIST (region);

-- Create partitions
CREATE TABLE orders_us PARTITION OF orders
    FOR VALUES IN ('us_east', 'us_west');

CREATE TABLE orders_eu PARTITION OF orders
    FOR VALUES IN ('eu_west', 'eu_north');

CREATE TABLE orders_default PARTITION OF orders
    FOR VALUES IN (DEFAULT);
```

### Partition Management
```sql
-- Remove partitioning
ALTER TABLE events PARTITION BY NOTHING;

-- Drop partition
DROP TABLE events_2024_01;
```

## User-Defined Functions

### SQL Functions
```sql
-- Simple function
CREATE OR REPLACE FUNCTION get_full_name(
    first_name STRING,
    last_name STRING
) RETURNS STRING AS $$
    SELECT first_name || ' ' || last_name
$$ LANGUAGE SQL IMMUTABLE;

-- With default parameters
CREATE FUNCTION format_currency(
    amount DECIMAL,
    currency STRING DEFAULT 'USD'
) RETURNS STRING AS $$
    SELECT currency || ' ' || amount::STRING
$$ LANGUAGE SQL;
```

### PL/pgSQL Functions
```sql
CREATE OR REPLACE FUNCTION calculate_discount(
    price DECIMAL,
    customer_type STRING
) RETURNS DECIMAL AS $$
DECLARE
    discount_rate DECIMAL;
BEGIN
    CASE customer_type
        WHEN 'premium' THEN discount_rate := 0.2;
        WHEN 'regular' THEN discount_rate := 0.1;
        ELSE discount_rate := 0;
    END CASE;
    RETURN price * (1 - discount_rate);
END;
$$ LANGUAGE plpgsql;
```

### Anonymous Blocks
```sql
-- One-time execution
DO $$
BEGIN
    UPDATE users SET status = 'inactive'
    WHERE last_login < now() - INTERVAL '90 days';
END
$$;
```

## Row-Level Security

### Enable RLS
```sql
-- Enable on table
ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

-- Force for table owner
ALTER TABLE documents FORCE ROW LEVEL SECURITY;
```

### Create Policies
```sql
-- SELECT policy (filter rows)
CREATE POLICY user_select ON documents
    FOR SELECT
    USING (owner_id = current_user() OR is_public = true);

-- UPDATE policy (with check)
CREATE POLICY user_update ON documents
    FOR UPDATE
    USING (owner_id = current_user())
    WITH CHECK (owner_id = current_user());

-- INSERT policy
CREATE POLICY user_insert ON documents
    FOR INSERT
    WITH CHECK (owner_id = current_user());

-- ALL policy (combines operations)
CREATE POLICY full_access ON documents
    FOR ALL
    USING (role = 'admin')
    WITH CHECK (role = 'admin');
```

### Disable/Drop RLS
```sql
-- Disable RLS
ALTER TABLE documents DISABLE ROW LEVEL SECURITY;

-- Drop policy
DROP POLICY user_select ON documents;
```

## Best Practices

1. **Always specify PRIMARY KEY** - CockroachDB requires it
2. **Use UUID for distribution** - Better than sequential IDs
3. **Normalize types** - STRING not TEXT, TIMESTAMPTZ not TIMESTAMP
4. **Add STORING to indexes** - Prevent additional lookups
5. **Use column families** - Group columns by access patterns
6. **Consider partitioning** - For large time-series data
7. **Enable RLS carefully** - Performance impact for security
8. **Test with invisible indexes** - Before making them visible